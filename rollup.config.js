import  * as fs from 'fs';
import  * as path from 'path';
import resolve from '@rollup/plugin-node-resolve';
import replace from '@rollup/plugin-replace';
import commonjs from '@rollup/plugin-commonjs';
import svelte from 'rollup-plugin-svelte';
import babel from 'rollup-plugin-babel';
import { terser } from 'rollup-plugin-terser';
import { mdsvex } from 'mdsvex';
import config from 'sapper/config/rollup.js';
import pkg from './package.json';
import frontMatter from 'front-matter';

const mode = process.env.NODE_ENV;
const dev = mode === 'development';
const legacy = !!process.env.SAPPER_LEGACY_BUILD;

const onwarn = (warning, onwarn) => (warning.code === 'CIRCULAR_DEPENDENCY' && /[/\\]@sapper[/\\]/.test(warning.message)) || onwarn(warning);

export default {
	client: {
		input: config.client.input(),
		output: config.client.output(),
		plugins: [
			replace({
				'process.browser': true,
				'process.env.NODE_ENV': JSON.stringify(mode)
			}),
			svelte({
				dev,
				hydratable: true,
				emitCss: true,
				extensions: ['.svelte', '.md'],
				preprocess: mdsvex({
					extension: '.md',
					layout: path.join(__dirname, 'src/routes/_md-layout.svelte'),
					markdownOptions: {
						typographer: true,
						linkify: true
					},
				}),
// 				preprocess: [
// 					{
// 						markup: ({content, filename}) => {
// 							if (path.extname(filename) !== '.md') {
// 								return;
// 							}

// 							// Sets contents for menu file
// 							const setFileContents = (menu) => {
// 								return `/*
// * WARNING: Do not change this file!
// * This file is automatically generated during build time by RollupJS and will be removed on every rebuild.
// * See rollup.config.js in the root folder of this project for more information.
// */

// module.exports = ${JSON.stringify(menu, null, 2)};`;
// 							};

// 							// Creates name based on id
// 							const getNameFromId = (id) => {
// 								return id.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
// 							}

// 							// Add item to menu
// 							const addItemFromAttributes = (menu, attributes) => {
// 								if (attributes.hasOwnProperty('id') && attributes.hasOwnProperty('title')) {
// 									const menuItem = {
// 										id: attributes.id,
// 										title: attributes.title,
// 										link: body !== '' ? true : false
// 									};
	
// 									if (attributes.hasOwnProperty('afterId')) {
// 										menuItem.afterId = attributes.afterId;
// 									}
	
// 									menu[attributes.id] = menuItem;
// 								}
// 							}

// 							const updateItem = (menu, attributes) => {

// 							}

// 							let { attributes, body } = frontMatter(content);
// 							const menuPath = path.join(__dirname, 'src/routes/_menu.js');
// 							const levels = filename.replace(path.join(__dirname, 'src/routes/documentation/'), '').split('/');
// 							const directories = levels.slice(0, -1);
// 							const parentDirectory = levels[directories.length - 2];
// 							const currentDirectory = levels[directories.length - 1];
// 							const file = levels[levels.length - 1];
// 							let indexFileExists = false;
// 							let directoryFileExists = false;
// 							let menu;

// 							try {
// 								indexFileExists = fs.existsSync(path.join(__dirname, 'src/routes/documentation/', levels.slice(0, -1).join('/'), 'index.md'));
// 							} catch (error) {}

// 							try {
// 								directoryFileExists = fs.existsSync(path.join(__dirname, 'src/routes/documentation/', levels.slice(0, -2).join('/'), file.replace('.md', '')));
// 							} catch (error) {}

// 							let fileContents;
							
// 							if (!fs.existsSync(menuPath)) {
// 								// menu = {};
// 								menu = [];
// 								fileContents = setFileContents(menu);

// 								fs.writeFileSync(menuPath, fileContents, (error) => {
// 									if (error) {
// 										throw error;
// 									}
// 								});
// 							} else {
// 								return;
// 							}

// 							// const isIntermediate = file === 'index.md' || directoryFileExists;
// 							menu = require(menuPath);
							
// 							// const createIntermediateItems = (object, keys) => {
// 							// 	console.log('createIntermediateItems 1', object, keys);

// 							// 	const key = keys.reverse().pop();

// 							// 	if (!object.hasOwnProperty(key)) {
// 							// 		const item = {
// 							// 			id: key,
// 							// 			title: getNameFromId(key),
// 							// 			link: false
// 							// 		};
// 							// 		object[key] = item;
// 							// 	}
								
// 							// 	console.log('createIntermediateItems 2', object, keys);

// 							// 	if (keys.length > 0) {
// 							// 		object = createIntermediateItems(object[key], keys.reverse());
// 							// 	}

// 							// 	return object;
// 							// }

// 							const createIntermediateItems = (array, keys, attributes, body) => {
// 								// TODOs
// 								// Update index items if there is a corresponding index.md in current directory or [directory].md in parent directory
// 								// Add normal doc items in the correct order

// 								const key = keys.shift();
// 								let index = array.findIndex((item) => item.id === key);

// 								if (index === -1) {
// 									const item = {
// 										id: key,
// 										title: getNameFromId(key),
// 										link: false,
// 										children: []
// 									};
// 									index = array.push(item) - 1;
// 									// console.log(`Add index item for ${key}.`, array);
// 								}

// 								// console.log('key, index, array', key, index, array);

// 								// console.log('keys', keys);
// 								if (keys.length > 0) {
// 									// const child = createIntermediateItems(array[array.length - 1].children, keys);
// 									const child = createIntermediateItems(array[index].children, keys, attributes, body);
// 									if (child) {
// 										// array[array.length - 1].children.push(child);
// 										array[index].children.push(child);
// 									}
// 								} else {
// 									if (attributes.hasOwnProperty('id') && attributes.hasOwnProperty('title')) {
// 										const menuItem = {
// 											id: attributes.id,
// 											title: attributes.title,
// 											link: body !== '' ? true : false,
// 											children: []
// 										};
		
// 										if (attributes.hasOwnProperty('afterId')) {
// 											menuItem.afterId = attributes.afterId;
// 										}

// 										// console.log('array[index]', array[index].children);
		
// 										// TODO: Add on correct index (afterId)
// 										array[index].children.push(menuItem);
// 									}
// 								}

// 								return array.children;
// 							}

// 							createIntermediateItems(menu, directories, attributes, body);

// 							console.log('--------------------------------------------------------------------------------');
// 							console.log('RELATIVE PATH', filename.replace(path.join(__dirname, 'src/routes/documentation/'), ''));
// 							console.log('DIRECTORIES', directories);
// 							console.log('PARENT DIRECTORY', parentDirectory);
// 							console.log('CURRENT DIRECTORY', currentDirectory);
// 							console.log('FILE', file);
// 							// console.log(path.join(__dirname, 'src/routes/', levels.slice(0, -1).join('/'), file.replace('.md', '')));
// 							console.log('indexFileExists', indexFileExists, path.join(__dirname, 'src/routes/documentation/', levels.slice(0, -1).join('/'), 'index.md'));
// 							console.log('directoryFileExists', directoryFileExists, path.join(__dirname, 'src/routes/documentation/', levels.slice(0, -2).join('/'), file.replace('.md', '')));
// 							console.log('menu', menu);
// 							console.log('--------------------------------------------------------------------------------\n\n');

// 							const createItem = (array, keys) => {

// 							};

// 							// /developers/nymea/install
// 							// developers							

// 							// Create intermediate item
// 							// let object = menu;
// 							// for (let i = 0; i < directories.length; i++) {
// 							// 	if (object.hasOwnProperty(directories[i])) {
// 							// 		object = object[directories[i]];
// 							// 	}
								
// 							// 	console.log('object', object);
// 							// }

// 							// directories.forEach((directory, index) => {
// 							// 	console.log(directory, index);

// 							// 	Object.keys(menu)

// 							// 	if (!menu.hasOwnProperty(directory)) {
// 							// 		attributes = {
// 							// 			id: directory,
// 							// 			title: getNameFromId(directory),
// 							// 			body: ''
// 							// 		};
// 							// 	}

// 							// 	console.log('attributes', attributes);

// 								// addItemFromAttributes(menu, attributes);

// 							// 	// if (!menu.hasOwnProperty(directory)) {
// 							// 	// 	addItemFromAttributes(menu, {
// 							// 	// 		id: directory,
// 							// 	// 		title: getNameFromId(directory),
// 							// 	// 		body: ''
// 							// 	// 	});
// 							// 	// }
// 							// });

// 							// if (isIntermediate === true) {
// 							// 	// Set or update intermediate item
// 							// 	if (menu[]) {

// 							// 	}
// 							// } else {
								
// 							// }

// 							// Check if there is a file in parent directory with same name as current directory
// 							// Check if there is an index file in current directory

// 							// Create category
// 							// if (menu.hasOwnProperty(currentDirectory) && file === 'index.md') {
// 							// 	// Replace content
// 							// 	addItemFromAttributes(menu, attributes);
// 							// } else if (!menu.hasOwnProperty(currentDirectory) && file === 'index.md') {
// 							// 	// Add content
// 							// 	addItemFromAttributes(menu, attributes);
// 							// } else if (!menu.hasOwnProperty(currentDirectory)) {
// 							// 	addItemFromAttributes(menu, {
// 							// 		id: currentDirectory,
// 							// 		title: getNameFromId(currentDirectory.id),
// 							// 		body: ''
// 							// 	});
// 							// }
// 							/* else if (!menu.hasOwnProperty(currentDirectory) && file !== 'index.md') {
// 								// Add content
// 							}*/

// 							fileContents = setFileContents(menu);

// 							fs.writeFileSync(menuPath, fileContents, (error) => {
// 								if (error) {
// 									throw error;
// 								}
// 							});
							
// 							// console.log('menu', menu, menu.menu);
// 							// console.log('filename', filename);
// 							// console.log('attributes', attributes);
// 							// console.log('body', body === '');
// 						}
// 					},
// 					mdsvex({
// 						extension: '.md',
// 						layout: path.join(__dirname, 'src/routes/_md-layout.svelte'),
// 						markdownOptions: {
// 							typographer: true,
// 							linkify: true
// 						},
// 					}),
// 					// function preprocess() {
// 					// 	const mdsvexPreprocess = mdsvex({
// 					// 		extension: '.md',
// 					// 		layout: path.join(__dirname, 'src/routes/_md-layout.svelte'),
// 					// 		markdownOptions: {
// 					// 			typographer: true,
// 					// 			linkify: true
// 					// 		},
// 					// 	});
// 					// 	console.log('mdsvexPreprocess', mdsvexPreprocess);
// 					// 	return mdsvexPreprocess;
// 					// }(),
// 					// {
// 					// 	markup: ({content, filename}) => {
// 					// 		console.log('content', content);
// 					// 		console.log('filename', filename);
// 					// 	}
// 					// }
// 				],
			}),
			resolve({
				browser: true,
				dedupe: ['svelte']
			}),
			commonjs(),

			legacy && babel({
				extensions: ['.js', '.mjs', '.html', '.svelte'],
				runtimeHelpers: true,
				exclude: ['node_modules/@babel/**'],
				presets: [
					['@babel/preset-env', {
						targets: '> 0.25%, not dead'
					}]
				],
				plugins: [
					'@babel/plugin-syntax-dynamic-import',
					['@babel/plugin-transform-runtime', {
						useESModules: true
					}]
				]
			}),

			!dev && terser({
				module: true
			})
		],

		onwarn,
	},

	server: {
		input: config.server.input(),
		output: config.server.output(),
		plugins: [
			replace({
				'process.browser': false,
				'process.env.NODE_ENV': JSON.stringify(mode)
			}),
			svelte({
				generate: 'ssr',
				dev,
				extensions: ['.svelte', '.md'],
				preprocess: mdsvex({
					extension: '.md',
					layout: path.join(__dirname, 'src/routes/_md-layout.svelte'),
					markdownOptions: {
						typographer: true,
						linkify: true
					},
				}),
			}),
			resolve({
				dedupe: ['svelte']
			}),
			commonjs()
		],
		external: Object.keys(pkg.dependencies).concat(
			require('module').builtinModules || Object.keys(process.binding('natives'))
		),

		onwarn,
	},

	serviceworker: {
		input: config.serviceworker.input(),
		output: config.serviceworker.output(),
		plugins: [
			resolve(),
			replace({
				'process.browser': true,
				'process.env.NODE_ENV': JSON.stringify(mode)
			}),
			commonjs(),
			!dev && terser()
		],

		onwarn,
	}
};
